// 0에서 N으로 만든다고 생각하기, 계단오르기 문제하고 비슷
// 2칸과 7칸씩만 오를 수 있다고 했을 때, dp배열은 각 계단별 도달하기 위한 최소횟수
// (dp[n]: n번째 계단으로 가기까지 최소 횟수)
// 만약 4번째 계단일때, 2칸전인 2번째 계단까지는 1번만에 올 수 있으니 2번째 계단을 거쳐 2번만에 올 수 있음.
// 만약 7번째 계단일때, 7칸전인 출발지로부터는 1번만에 올 수 있으니 1번만에 올 수 있음.
// 만약 14번째 계단일때, 2칸전인 12번째 계단까지는 6번만에 올 수 있고 (2칸씩 6번),
// 7칸전인 7번째 계단까지는 1번만에 올 수 있으니, (6 + 1)번 or (1 + 1) => dp[14] = 2
// A, B칸만큼 비교하면서 더 적은횟수로 오는방법으로 갱신해 주면 됨.
// 최소값을 찾는 문제기 때문에 도달하지 못하는곳은 Int형 최대값으로 채우고 시작함. (1)
#include <stdio.h>
#define MIN(a, b) ((a < b) ? a : b)
int main() {
    int dp[1000001] = {0};
    int N, A, B;
    scanf("%d %d %d", &N, &A, &B);
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        dp[i] = __INT_MAX__; // (1)
        if (i - A >= 0) dp[i] = MIN(dp[i], dp[i - A] + 1);
        if (i - B >= 0) dp[i] = MIN(dp[i], dp[i - B] + 1);
    }
    printf("%d", dp[N] == __INT_MAX__ ? -1 : dp[N]);
}